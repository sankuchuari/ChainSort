# ChainSort
一种链式排序方法

提供了python和c++解决方案
# 一、算法概要

## ChainSort 的主要思路是：

1.建立有序链表：
通过遍历原数组中的每个元素，将其插入到一个“双向链表”结构中，链表始终保持按元素值的从小到大排序。

2.构建地址映射
完成链表构建后，将链表中节点从头到尾依次赋予新的“目标位置”，并建立一个从“目标位置”到“原下标”的逆映射。

3.循环置换
最后，利用该映射对原数组进行就地交换，将每个元素移动到正确的排序位置。

## 该算法使用了两个主要数据结构：

1.Chack[]：标记某个位置是否在最终交换环中已被处理。

2.Chain[][3]：一个二维数组，每一行对应一个链表节点，存储了“前驱 / 原下标 / 后继”等信息（后期还会重用前驱指针存储“目标下标”）。

## ChainSort 可以被拆解为以下几个阶段：
1.构建有序链
2.给链表节点分配最终目标位置
3.构建逆映射
4.循环置换



# 二、示例演示
下面先结合示例大致说明算法流程，然后再对代码中每个关键部分做详细解释。

以数组 arr = [2,4,1,5,8,7,3,9,9,9,11] 为例，长度 len = 11。

##  建立有序链表（插入顺序演示）
使用一个二维数组 Chain[len][3] 来模拟双向链表，每行代表一个节点
### 数组Chain各列作用
Chain[i][0]：前驱（初始）

Chain[i][1]：该节点在原数组中的下标 i

Chain[i][2]：后继（初始）
### 初始化三个指针
head：链表头节点下标

end：链表尾节点下标

mid：插入时辅助定位的中间指针

pointer：以及一个临时遍历指针

## 构建有序链表
### （1）插入第 0 个元素 arr[0] = 2

此时链表为空，直接把它作为唯一节点：

Chain[0][0] = -1; 

Chain[0][1] = 0; 

Chain[0][2] = -1;

head = 0; 

end = 0; 

mid = 0; 

lenChain = 1;
### （2）插入第 1 个元素 arr[1] = 4
判断：4 >= 2 → 插入到链表尾部。

新节点 1 的前驱是旧尾 0，后继 = -1。

旧尾节点 0 的后继设为 1。

end 更新为 1。

mid 向后移动一次 → mid = Chain[0][2] = 1。

链表结构：(0) -→ (1)。

### （3）插入第 2 个元素 arr[2] = 1
判断：1 <= 2 → 插入到链表头部。

新节点 2 的前驱 = -1，后继 = head(0)。

原头 0 的前驱 = 2。

更新 head = 2。

mid 向前移动一次 → mid = Chain[1][0] = 0（或者根据实现细节，可能还要看代码里 mid 的初始赋值方式）。

链表结构：(2) -→ (0) -→ (1)；对应的值顺序：[1,2,4]。

### （4）插入第 3 个元素 arr[3] = 5
5 >= 4 → 插入到链尾：

链表变为 1 → 2 → 4 → 5。

### （5）插入第 4 个元素 arr[4] = 8
8 >= 5 → 继续插到尾部。

链表顺序：1 → 2 → 4 → 5 → 8。

### （6）插入第 5 个元素 arr[5] = 7
7 >= 5 但 7 < 8 → 介于链尾和中间某处，需要找准确插入位置：

如果和 mid 比较发现 7 > arr[mid]，则从 mid 往后找；否则从头往后找（具体要看代码如何区分）。

最终插入到 8 的前面。

链表顺序：1 → 2 → 4 → 5 → 7 → 8。

以此类推，将 3,9,9,9,11 等元素也分别插入正确位置，得到一个完整的有序链表（仅存储节点间前驱后继关系，内部 Chain[i][1] 还是原数组下标）。

## 构建目标下标 + 逆映射
当链表插入完毕后，我们就有了一个从小到大的“链式排序”。

接下来代码会遍历链表，从 head 节点开始到 end 节点结束，依次给每个节点分配“目标位置”。

例如，假设链表有 11 个节点，初始 lenChain = 11，在遍历过程中令 Chain[pointer][0] = lenChain - 1; 并让 pointer 往后继走，lenChain 依次递减。

这样做会让“最小值”的节点得到最大的下标，然后逐渐往下分配。

结果是 Chain[i][0] 不再表示“前驱”，而变成“该节点最终应该放在哪个下标”。

## 构建逆映射

再次遍历 Chain，执行 Chain[Chain[i][0]][2] = i;。

这会利用刚刚得到的“目标下标” Chain[i][0] 作为行索引，把 i 存进那一行的第 2 列；从而形成“目标位置” → “原节点下标”的对应。

### 3. 利用循环置换进行最终排序
最后一步，遍历数组下标 0 到 len-1，对于每个 i：

若 Chack[i] == false（未处理），则：

保存当前节点的值到 TempNum：TempNum = array[Chain[i][1]]。

按照 Chain[i][2] 找到下一个需要被放置的节点，用 pointer 记录；

不断把“下一个节点”的值放到“目标位置”，直到回到起点 i，形成一个置换环；

将 TempNum 放到该环的最后一个目标位置，完成一整个环的元素就地移动。

用 Chack[] 标记已处理位置，防止重复。

这样做的好处是：在一次循环里，可以把属于同一个“环”的所有元素都移动到正确位置，只要 Chack 标记好，就不会发生重复移动或遗漏。
# 三、算法优缺点与复杂度
## 优点
就地排序：利用循环置换，最终结果直接写回原数组，无需额外复制所有元素。

链表插入：在插入阶段可以灵活地从头或尾或中间开始搜索，适合部分有序或中间值较多的场景。
## 缺点

实现复杂：需要维护多个指针（head/end/mid/pointer）及 Chain 数组的“角色切换”，对初学者不太友好。

最坏情况下复杂度偏高：如果大量元素都介于中间，每次都要遍历一部分链表查找插入位置，可能退化到 O(N²)。

稳定性：算法中插入和比较方式决定了对于重复元素的顺序是否稳定，需要仔细分析插入逻辑中的 <= / >= 以及最后置换环是否会打乱等。
## 时间复杂度
最好情况：若新元素大多数时候直接插到尾部或头部，插入阶段接近 O(N)，加上最后的循环置换 O(N)，整体可达 O(N)。

平均或最坏情况：若大量元素介于中间，需要在链表中做遍历插入，可能出现 O(N²) 行为。
